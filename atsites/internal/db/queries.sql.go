// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
)

const deleteDocument = `-- name: DeleteDocument :exec
DELETE FROM documents
WHERE repo = ? AND rkey = ?
`

type DeleteDocumentParams struct {
	Repo string
	Rkey string
}

func (q *Queries) DeleteDocument(ctx context.Context, arg DeleteDocumentParams) error {
	_, err := q.db.ExecContext(ctx, deleteDocument, arg.Repo, arg.Rkey)
	return err
}

const deletePublication = `-- name: DeletePublication :exec
DELETE FROM publications
WHERE repo = ? AND rkey = ?
`

type DeletePublicationParams struct {
	Repo string
	Rkey string
}

func (q *Queries) DeletePublication(ctx context.Context, arg DeletePublicationParams) error {
	_, err := q.db.ExecContext(ctx, deletePublication, arg.Repo, arg.Rkey)
	return err
}

const getDocumentsForPublication = `-- name: GetDocumentsForPublication :many
SELECT document_json, rkey
FROM documents
WHERE publication_repo = ? AND publication_rkey = ?
AND repo = publication_repo -- don't let strangers inject documents into others' publications
ORDER BY rowid DESC
`

type GetDocumentsForPublicationParams struct {
	PublicationRepo string
	PublicationRkey string
}

type GetDocumentsForPublicationRow struct {
	DocumentJson []byte
	Rkey         string
}

func (q *Queries) GetDocumentsForPublication(ctx context.Context, arg GetDocumentsForPublicationParams) ([]GetDocumentsForPublicationRow, error) {
	rows, err := q.db.QueryContext(ctx, getDocumentsForPublication, arg.PublicationRepo, arg.PublicationRkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentsForPublicationRow
	for rows.Next() {
		var i GetDocumentsForPublicationRow
		if err := rows.Scan(&i.DocumentJson, &i.Rkey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublication = `-- name: GetPublication :one
SELECT record_json
FROM publications
WHERE repo = ? AND rkey = ?
`

type GetPublicationParams struct {
	Repo string
	Rkey string
}

func (q *Queries) GetPublication(ctx context.Context, arg GetPublicationParams) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getPublication, arg.Repo, arg.Rkey)
	var record_json []byte
	err := row.Scan(&record_json)
	return record_json, err
}

const getPublications = `-- name: GetPublications :many
SELECT record_json, rkey
FROM publications
WHERE repo = ?
ORDER BY rowid DESC
`

type GetPublicationsRow struct {
	RecordJson []byte
	Rkey       string
}

func (q *Queries) GetPublications(ctx context.Context, repo string) ([]GetPublicationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPublications, repo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicationsRow
	for rows.Next() {
		var i GetPublicationsRow
		if err := rows.Scan(&i.RecordJson, &i.Rkey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const storeDocument = `-- name: StoreDocument :exec
INSERT INTO documents (repo, rkey, publication_repo, publication_rkey, document_json)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(repo, rkey) DO UPDATE SET document_json=excluded.document_json, publication_repo=excluded.publication_repo, publication_rkey=excluded.publication_rkey
`

type StoreDocumentParams struct {
	Repo            string
	Rkey            string
	PublicationRepo string
	PublicationRkey string
	DocumentJson    []byte
}

func (q *Queries) StoreDocument(ctx context.Context, arg StoreDocumentParams) error {
	_, err := q.db.ExecContext(ctx, storeDocument,
		arg.Repo,
		arg.Rkey,
		arg.PublicationRepo,
		arg.PublicationRkey,
		arg.DocumentJson,
	)
	return err
}

const storePublication = `-- name: StorePublication :exec
INSERT INTO publications (repo, rkey, record_json)
VALUES (?, ?, ?)
ON CONFLICT(repo, rkey) DO UPDATE SET record_json=excluded.record_json
`

type StorePublicationParams struct {
	Repo       string
	Rkey       string
	RecordJson []byte
}

func (q *Queries) StorePublication(ctx context.Context, arg StorePublicationParams) error {
	_, err := q.db.ExecContext(ctx, storePublication, arg.Repo, arg.Rkey, arg.RecordJson)
	return err
}
