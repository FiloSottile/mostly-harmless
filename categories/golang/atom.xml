<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | PyTux]]></title>
  <link href="https://filippo.io/categories/golang/atom.xml" rel="self"/>
  <link href="https://filippo.io/"/>
  <updated>2014-06-29T14:51:21+02:00</updated>
  <id>https://filippo.io/</id>
  <author>
    <name><![CDATA[Filippo Valsorda]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Why Go is elegant and makes my code elegant]]></title>
    <link href="https://filippo.io/why-go-is-elegant-and-makes-my-code-elegant/"/>
    <updated>2014-03-26T18:16:00+01:00</updated>
    <id>https://filippo.io/why-go-is-elegant-and-makes-my-code-elegant</id>
    <content type="html"><![CDATA[<p>This is a enthusiast blog post. I’m not even gonna speak about how concurrency comes easy with Go. Honestly, I’m not good enough to speak about it. I’ll just speak about how using Go in my everyday programming makes me happy.</p>

<p>Go has elegance, good tools and has had the possibility to start designing from scratch.</p>

<p>The following should not be a list but a tree, since good design decisions enable other good design decision. But I’ll go over them as they come to my mind.</p>

<h3 id="every-package-has-a-unique-name-in-the-universe">Every package has a unique name in the universe</h3>
<p>If you write a package, it will have a name. A unique one. In all the universe. Like, <code>github.com/FiloSottile/TripleSec</code> or <code>filippo.io/foobar</code>.</p>

<p>This is <strong>awesome</strong>. First and most obviously, <code>import</code> statements are sure, clear things. You import packages by their full name and you know what you are importing. No need for <code>bundler</code> or <code>requirements.txt</code>.</p>

<p>Second, you can keep a tree of the packages you use or develop on your disk, and it remains tidy by itself. You just put them in <code>$GOPATH/THEIR/FULL/NAME</code> and both you and the toolkit always know where they are.</p>

<p>Finally, most of the times the name will tell you <em>and your toolkit</em> where to get that package. If the package name starts with <em>bitbucket.com</em>, <em>github.com</em> or <em>code.google.com</em> then you just need to run <code>go get NAME</code> and it will get downloaded for you. Automatically.</p>

<!-- more -->

<h3 id="godoc">GoDoc</h3>

<p>Go has a <a href="http://blog.golang.org/godoc-documenting-go-code">clear, easy, multi-output documentation style</a>. You just write comments and there’s a tool that will write txt, man pages and HTML for you.</p>

<p>Mix this and the above and you get <a href="http://godoc.org">godoc.org</a>. The site will index all the packages it can crawl, generate docs for them and provide them to you at <em>http://godoc.org/PACKAGE_NAME</em>. All of the docs, in the same place, automatically. <strong>You literally just have to write comments and push and it’s like you registered the package on PyPi, generated the docs and uploaded them</strong>.</p>

<h3 id="compiling-and-static-binaries--with-easy-cross-compiling">Compiling and static binaries (+ with easy cross-compiling)</h3>

<p>Go is compiled. This has a number of advantages, first being all the errors that can be detected by the compiler, and speed. But usually there’s a tradeoff: Makefiles get messy, dynamic libraries requirements on the target machines.</p>

<p>Go solves all these: there are no Makefiles at all (or requirements.txt or metadata whatsoever), just imports and at most build inclusion/exclusion statements at top of the file; the binaries are static.</p>

<p>You just compile a binary with the libraries you have on your system (see point 1) and ship it to the machine that runs it. No dependencies. No interpreter versions.</p>

<p>Or if you just want to solve that Project Euler problem, <code>go run solution.go</code>. I don’t miss Python anymore.</p>

<p>And by mixing good design, good tools and good community, you get <a href="https://github.com/laher/goxc">cross-compilation for free</a>.</p>

<h3 id="static-types-that-i-have-to-type-only-once">Static types, that I have to type only once</h3>

<p>Static types are good, if they don’t slow me down. Go simply figured out that you just have to define them for functions parameters and return values. Think about it, (almost) all variables are parameters, receive a return value from a function or are defined as an explicit value.</p>

<p>When I happen to explicitly define a type, I’m probably doing something complex enough that static types are only gonna be helpful anyway.</p>

<h3 id="a-unique-documented-style">A unique, documented style</h3>

<p>Go code has an official style. It’s part of the language. It’s documented. And patterns are made explicit in the <a href="http://blog.golang.org/">blog posts</a>, that are committed to the same repositories as the Go tools.</p>

<p>And also here there’s an awesome tool. <code>go fmt</code> will take your source code and format it according to the style. No more “personal preferences” and discussions.</p>

<p>This makes reading Go code easier, whoever wrote it and whatever the project.</p>

<!-- As Linus Torvalds put it in the kernel [`CodingStyle`][codingstyle]: -->

<h3 id="pleasant-conventions">Pleasant conventions</h3>

<p>Go has some conventions that affect the behavior of your programs. These are easy and natural, and simplify the language without adding confusion.</p>

<ul>
  <li>Anything that starts with an upper case letter is exported. Everything else is not.</li>
  <li>If you have tests and benchmarks (you better have them, Go makes it so easy to write them), you put them in <code>*_test.go</code>.</li>
  <li>You write some Assembly, just put it in a file named like <code>*_amd64.s</code></li>
</ul>

<h3 id="control-flow-is-explicit-and-in-your-hands">Control flow is explicit and in your hands</h3>

<p>There are no exceptions that can traverse your code up to who knows where. Functions return a error, you handle it, or just return it.</p>

<p>Tests follow the same philosophy: you explicitly check for errors or expected states and <code>.Fail</code> the test if you want.</p>

<h3 id="even-if-its-young-it-has-a-decent-library">Even if it’s young it has a decent library</h3>

<p>I wrote <a href="https://github.com/FiloSottile/TripleSec/">Golang TripleSec</a> using only standard and <code>go.crypto</code> libraries. And they are fast and pretty. (Ok, I’m cheating, there’s Adam writing Go crypto libs, but also the rest is good!)</p>

<p>Also, thanks to point 1, it’s seamless to use external libraries, obviously.</p>

<h3 id="theres-no-pointer-arithmetics-but-no-flexibility-is-lost">There’s no pointer arithmetics but no flexibility is lost</h3>

<p>Go has no low-level memory arithmetics, but pointers, <code>&amp;</code> and <code>*</code> are still there for your usual pass-by-pointer needs. This alone kills a lot of complexity and potential bugs.</p>

<p>However flexible array pointers are still there, on disguise: they are called <strong>slices</strong>, actually just a struct of a pointer, a own length and a length of the underlying allocated memory (<em>capacity</em>). The built-in length means that APIs don’t need to explicitly pass it around and built-in capacity means no more silent overflows and segfaults. A bunch of built-ins come bundled to seamlessly handle length, capacity, copying and reallocation.</p>

<p>It’s how C arrays should have always worked if performance wasn’t prioritized over simplicity, security… everything, actually.</p>

<h3 id="it-made-the-heartbleed-checker-possible">It made the Heartbleed checker possible</h3>

<p>A new one: thanks to the crypto/tls library I wrote <a href="http://filippo.io/Heartbleed/">the Heartbleed checker</a> in one hour, plus a couple for the web side (but I’m just a bad web developer).</p>

<p>Then rewriting the backed entirely in Go allowed me to scale to 12,000 requests a minute over 40 machines, each of them requiring me to open a HTTPS connection and potentially wait some seconds.</p>

<hr />

<p>So, this is a quick recap of what I loved about programming in Go. I probably missed something and will be adding things over time.</p>

<p>If you want to share your opinion on Go, I’m <a href="https://twitter.com/FiloSottile">@FiloSottile</a> on Twitter. And if you’ve never tried Go, give it a shot! It’s not only about concurrency!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Callback-based combinations (in Go)]]></title>
    <link href="https://filippo.io/callback-based-combinations-in-go/"/>
    <updated>2014-01-16T15:20:00+01:00</updated>
    <id>https://filippo.io/callback-based-combinations-in-go</id>
    <content type="html"><![CDATA[<p>Let’s have a look at this task: generate all the <strong>combinations of <em>k</em> elements out of <em>N</em></strong>. That is, all the <em>unordered k-tuples</em> made of elements from a pool of length N. <a href="https://en.wikipedia.org/wiki/Combination">See Wikipedia</a> for more.</p>

<p>An example of an application: if you are bruteforcing two misspellings in a password, the optimal set of couples of characters to bruteforce at the same time is the set of all the combinations of 2 characters out of the password.</p>

<p>There are a number of ways you can do this in code. Algorithm-wise you have to choose between a recursive approach and an iterative one. The recursive one might be more immediate for some people, but it does. Not. Scale. (<em>Recursion limit reached</em> anyone?) Also in some languages <strong>function calls are really expensive</strong>.</p>

<p>However what this article is about is how to grab the output. First you have to decide whether to return <em>k</em>-tuples of indices in 0 – N-1 or of actual pool elements.</p>

<p>For example with a pool of elements of <code>qwerty</code> and a <em>k</em> of 2, you can decide to return values like <code>(q, t)</code> and <code>(t, y)</code> or <code>(0, 4)</code> and <code>(4, 5)</code>.</p>

<!-- more -->

<p>My opinion is that you should always prefer the indices:</p>

<ul>
  <li>to return actual elements you have to pass the pool to the algorithm;</li>
  <li>you can reuse a set of indices over two same-size pools;</li>
  <li>for some tasks you can avoid the work of extracting the values from the pool by index all the times (e.g. if you filter them);</li>
  <li>by returning elements you lose information about their index that might be irrecoverable (if there are duplicates in the pool) or expensive to recover (<code>O(N)</code>);</li>
  <li>sometimes, well, you just need the indices.</li>
</ul>

<p>Then, you can think to a number of approaches here:</p>

<ol>
  <li>just return an array or a set of all the combinations</li>
  <li>yield them (if you have support for generators)</li>
  <li>call a callback on each one</li>
  <li>plainly process them where you generate them</li>
</ol>

<p>I prefer by far the callback approach:</p>

<ul>
  <li>it is supported in much more languages than generators;</li>
  <li>can be used elegantly and succinctly with anonymous functions;</li>
  <li><strong>doesn’t require <code>k*N</code> memory</strong>, you can just filter or process them on the fly;</li>
  <li>you can build any other approach over it, e.g. by passing a <code>append</code> function as the callback;</li>
  <li>by using closures you can share the callee scope;</li>
  <li>keeps your code <a href="https://en.wikipedia.org/wiki/Don%27t_Repeat_Yourself">DRY</a>.</li>
</ul>

<p>So, code! Here are the Go snippets for combinations with and without repetitions. Most of it was translated to Go from <a href="http://docs.python.org/2/library/itertools.html#itertools.combinations">the Python documentation</a> and adapted according to the contents of this article.</p>

<p><div><script src='https://gist.github.com/8463644.js?file=combinations.go'></script>
<noscript><pre><code>func combinations(n, m int, f func([]int)) {
	// For each combination of m elements out of n
	// call the function f passing a list of m integers in 0-n
	// without repetitions
	
	// TODO: switch to iterative algo
	s := make([]int, m)
	last := m - 1
	var rc func(int, int)
	rc = func(i, next int) {
		for j := next; j &lt; n; j++ {
			s[i] = j
			if i == last {
				f(s)
			} else {
				rc(i+1, j+1)
			}
		}
		return
	}
	rc(0, 0)
}</code></pre></noscript></div>
</p>

<p><div><script src='https://gist.github.com/8463644.js?file=combinations_with_replacement.go'></script>
<noscript><pre><code>func combinations_with_replacement(n, m int, f func([]int)) {
	// For each combination of m elements out of n
	// call the function f passing a list of m integers in 0-n
	// with repetitions
	indices := make([]int, m)
	f(indices)

	for {
		var i int
		for i = m - 1; i &gt;= 0; i-- {
			if indices[i] != n-1 {
				break
			}
		}
		if i &lt; 0 {
			break
		}

		indices_i := indices[i]
		for k := i; k &lt; m; k++ {
			indices[k] = indices_i + 1
		}
		f(indices)
	}
}</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
</feed>
