<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: crypto | PyTux]]></title>
  <link href="http://filosottile.github.com/blog/categories/crypto/atom.xml" rel="self"/>
  <link href="http://filosottile.github.com/"/>
  <updated>2013-01-12T00:30:21+01:00</updated>
  <id>http://filosottile.github.com/</id>
  <author>
    <name><![CDATA[Filippo Valsorda]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Please take this and go signing those updates]]></title>
    <link href="http://filosottile.github.com/please-take-this-and-go-signing-those-updates/"/>
    <updated>2012-12-19T20:47:00+01:00</updated>
    <id>http://filosottile.github.com/please-take-this-and-go-signing-those-updates</id>
    <content type="html"><![CDATA[<p>If your program does any sort of self-updating, it is <em>fundamental</em> that you <strong>check the update payload integrity</strong>. And no, fetching it over HTTPS might <a href="http://docs.python.org/2/library/urllib2.html">not</a> <a href="http://docs.python.org/3.3/library/urllib.request.html">be</a> <a href="http://www.rubyinside.com/how-to-cure-nethttps-risky-default-https-behavior-4010.html">enough</a>.</p>

<p>Otherwise, anyone who can tamper with the traffic of your users, like anyone on their same network, or their ISP, can trivially get <strong>code execution</strong> by modifying the update while your program downloads it. And yes, <a href="http://www.infobytesec.com/down/isr-evilgrade-Readme.txt">it is exploited in the wild and it is easy</a>.</p>

<p>The common way to sign something is to use RSA, but you might not want to rely on <em>yet another external dependency</em>, with God knows which license...<br/>
Then, <strong>take this</strong>! It's a drop-in, <em>zero-dependency</em> <strong>RSA signature verifying function</strong> that run on Python 2.4+ (seriously) and... it's in the Public Domain (<a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a>), it's yours.</p>

<p>``` python rsa_verify.py https://gist.github.com/4340076#file-rsa_verify-py
def rsa_verify(message, signature, key):</p>

<pre><code>from struct import pack
from hashlib import sha256 # You'll need the backport for 2.4 http://code.krypto.org/python/hashlib/
from sys import version_info
def b(x):
    if version_info[0] == 2: return x
    else: return x.encode('latin1')
assert(type(message) == type(b('')))
block_size = 0
n = key[0]
while n:
    block_size += 1
    n &gt;&gt;= 8
signature = pow(int(signature, 16), key[1], key[0])
raw_bytes = []
while signature:
    raw_bytes.insert(0, pack("B", signature &amp; 0xFF))
    signature &gt;&gt;= 8
signature = (block_size - len(raw_bytes)) * b('\x00') + b('').join(raw_bytes)
if signature[0:2] != b('\x00\x01'): return False
signature = signature[2:]
if not b('\x00') in signature: return False
signature = signature[signature.index(b('\x00'))+1:]
if not signature.startswith(b('\x30\x31\x30\x0D\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x01\x05\x00\x04\x20')): return False
signature = signature[19:]
if signature != sha256(message).digest(): return False
return True
</code></pre>

<p>```</p>

<p><a href="https://gist.github.com/4340076">Here</a> are the instructions on how to generate your private and public keys and how to sign new updates. Don't worry, it's all really easy; if you happen to encounter any issues, shoot me a mail at <code>filippo.valsorda -&gt; gmail.com</code>!</p>

<p>I am sufficiently proficient only in Python, so if any C, Perl, PHP or Brainfuck guru wants to show up and contribute the same function in another language, it would be awesome!</p>

<p>Now you don't have any excuses anymore (at least you Python devs): <strong>go signing your updates</strong>!<br/>
(And maybe also <a href="https://www.twitter.com/FiloSottile">following me on Twitter</a>)</p>
]]></content>
  </entry>
  
</feed>
